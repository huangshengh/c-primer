#include <iostream>
#include <deque>
#include <string>
using namespace std;

int main()
{
	string word;
	deque<string> de;
	while (cin >> word)//需要换行输入文件结束符才算结束输入
		/*这种阻塞式的方式有一个特点：只有按下回车之后才有可能检测在此之前是否有Ctrl + Z按下。还有一个特点就是：如果输入缓冲区中有可读的数据则不会检测Ctrl + Z（因为有要读的数据，还不能认为到了流的末尾）。还有一点需要知道：Ctrl + Z产生的不是一个普通的ASCII码值，也就是说它产生的不是一个字符，所以不会跟其它从键盘上输入的字符一样能够存放在输入缓冲区。明白了这几点之后就可以来解释楼主提出的问题了。

		从键盘上输入abcd^z 加 回车之后在Windows系统上是这样处理的：由于回车的作用，前面的 abcd 等字符被送到输入缓冲区（注意：上面说过了，^z不会产生字符，所以更不会存储到输入缓冲区，缓冲区中没有 ^z 的存在）。这时，cin.get() 检测到输入缓冲区中已经有数据存在（因此不再检查是否有 ^z 的输入），于是从缓冲中读取相应的数据。如果都读取完了，则输入缓冲区重新变为空，cin.get() 等待新的输入。可见，尽管有 ^z 按下，但是由于在此之前还有其它输入字符（abcd），所以流也不会结束。

		因此，输入流结束的条件就是：^z 之前不能有任何字符输入（回车除外），否则 ^z 起不到流结束的作用。*/
		de.push_back(word);
	for (auto c:de)//此处也可以使用迭代器，都一样的效果
		cout << c<<endl;
	system("pause");
	return 0;
}